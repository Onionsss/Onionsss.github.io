<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[极简的MVP设计模式配合UI框架]]></title>
    <url>%2F2017%2F05%2F16%2F%E6%9E%81%E7%AE%80MVP%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%E6%90%AD%E9%85%8DUI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[MVP可以实现视图和数据的解耦 ###如图所示 MVP使M与V分离 实现了解耦 定义BaseView 所有视图的通用接口(activity fragment)12345678910111213public interface BaseView &#123; /** * 初始化数据 */ void loadData(); /** * 更新View的状态 * @param state */ void updateState(int state);&#125; updateState整个方法是由我们来根据网络返回的数据或者来判断整个View的状态,定义了三个状态值,由此来展示loading页面 或者 error的页面123456//加载状态public static final int STATUS_LOADING = 100;//成功状态public static final int STATUS_SUCCESS = 101;//失败状态public static final int STATUS_ERROR = 102; 接着去定义通用的接口BaseViewImpl123456public interface BaseViewImpl&lt;D&gt; extends BaseView&#123; void attachPre(); void showData(List&lt;D&gt; list);&#125; attachPre 由View来关联相应的Presenter 可以在定义的BaseActivity里调用绑定PresenterBasePresenter123456789101112public interface BasePresenter&lt;V&gt; &#123; /** * 绑定View * @param view */ void attachView(V view); /** * 解绑View */ void detachView();&#125; BasePresenter的实现类 基类123456789101112131415161718192021222324252627282930313233343536373839404142public abstract class BasePresenterImpl&lt;V extends BaseView&gt; implements BasePresenter&lt;V&gt;&#123; public Context mContext; public V mBaseView; private CompositeSubscription mCompositeSubscription; public BasePresenterImpl(Context context)&#123; mContext = context; &#125; @Override public void attachView(V view) &#123; mBaseView = view; &#125; @Override public void detachView() &#123; this.mBaseView = null; onUnsubscribe(); //解绑 &#125; /** * 加载数据 */ public abstract void loadData(); //RXjava取消注册，以避免内存泄露 public void onUnsubscribe() &#123; if (mCompositeSubscription != null &amp;&amp; mCompositeSubscription.hasSubscriptions()) &#123; mCompositeSubscription.unsubscribe(); &#125; &#125; public void addSubscription(Observable observable, Subscriber subscriber) &#123; if (mCompositeSubscription == null) &#123; mCompositeSubscription = new CompositeSubscription(); &#125; mCompositeSubscription.add(subscriber); &#125;&#125; 在BasePresenterImpl里绑定View ,由此子类可以根据View来更新状态MVP就是基类的实现就是这么简单,现在来创建activity来试试手, 首先创建一个BaseActivity,抽取一些公共的代码1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class BaseActivity&lt;T extends BasePresenter,D&gt; extends AppCompatActivity implements BaseViewImpl&lt;D&gt;&#123; public T mPresenter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); /** * 绑定Presenter */ attachPre(); View view = initView(LayoutInflater.from(this)); setContentView(view); ButterKnife.bind(this); findView(view); loadData(); &#125; protected abstract View initView(LayoutInflater from); public abstract void findView(View view); @Override protected void onDestroy() &#123; super.onDestroy(); if(mPresenter != null) mPresenter.detachView(); ButterKnife.unbind(this); &#125; /** * error的统一处理 * @param error */ public void error(Throwable error)&#123; if(error instanceof NetworkErrorException)&#123; Toast.makeText(this,&quot;网络错误&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 创建HomeActivity去访问网络以及加载数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class HomeActivity extends BaseActivity&lt;HomePresenter, NewsList.NewsEntity&gt; &#123; @Bind(R.id.recy) RecyclerView mRecy; private NewsListAdapter mNewsListAdapter; private LoadStuatus mLoadStuatus; @Override public View initView(LayoutInflater inflater) &#123; /** * UI框架 */ mLoadStuatus = new LoadStuatus(this); /** * 实现成功页面的View */ mLoadStuatus.addSuccessView(inflater.inflate(R.layout.activity_home, null)); /** * 绑定BaseView来实现页面点击加载 */ mLoadStuatus.bindView(this); return mLoadStuatus; &#125; @Override public void findView(View view) &#123; mRecy.setLayoutManager(new LinearLayoutManager(this)); mNewsListAdapter = new NewsListAdapter(this); mRecy.setAdapter(mNewsListAdapter); &#125; @Override public void attachPre() &#123; mPresenter = new HomePresenter(this); mPresenter.attachView(this); &#125; @Override public void showData(List&lt;NewsList.NewsEntity&gt; list) &#123; mNewsListAdapter.flush(list); &#125; @Override public void loadData() &#123; mPresenter.loadData(); &#125; /** * 更新页面 */ @Override public void updateState(int state) &#123; mLoadStuatus.updateView(state); &#125;&#125; 这里的loadStuatus是一个帧布局用来存放我们的三个页面errorPage,LoadPage,SuccessPage都是根据P层的回调来实现在来看一下P层的实现1234567891011121314151617181920public class HomePresenter extends BasePresenterImpl&lt;HomeActivity&gt;&#123; public HomePresenter(Context context) &#123; super(context); &#125; @Override public void loadData() &#123; Subscription subscribe = RetrofitUtils.getinstance(mContext).buildNews().getNews() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(bean -&gt; mBaseView.showData(bean.getNews()), //onNext() 去更新页面 error -&gt; &#123; mBaseView.error(error); // 请求网络失败 在BaseActivity定义了公共的处理方法 mBaseView.updateState(LoadStuatus.STATUS_ERROR); //更新页面 显示失败的页面 &#125;, () -&gt; mBaseView.updateState(LoadStuatus.STATUS_SUCCESS));// onComplete 完成页面更新,显示成功的页面 addSubscription(subscribe); &#125;&#125; P层很简单 就是访问网络 当请求接下来看一下我们的UI框架 定义了统一处理页面状态的状态码以及如何去正确的显示页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class LoadStuatus extends FrameLayout &#123; private static final String TAG = &quot;TAG&quot;; BaseView nView; @Bind(R.id.error) View mErrorView; @Bind(R.id.loading) View mLoadingView; View successView; //加载状态 public static final int STATUS_LOADING = 100; //成功状态 public static final int STATUS_SUCCESS = 101; //失败状态 public static final int STATUS_ERROR = 102; public LoadStuatus(Context context) &#123; this(context, null); &#125; public LoadStuatus(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public LoadStuatus(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; public void addSuccessView(View view)&#123; successView = view; addView(successView); successView.setVisibility(GONE); &#125; public void bindView(BaseView view) &#123; this.nView = view; mErrorView.setOnClickListener(v -&gt; &#123; if(nView == null) throw new NoBindViewException(&quot;没有绑定View&quot;); nView.loadData(); &#125;); &#125; public void init() &#123; View.inflate(getContext(), R.layout.status, this); ButterKnife.bind(this); &#125; public void updateView(int currentStatus) &#123; switch (currentStatus) &#123; case STATUS_ERROR: successView.setVisibility(GONE); mErrorView.setVisibility(VISIBLE); mLoadingView.setVisibility(GONE); break; case STATUS_LOADING: successView.setVisibility(GONE); mErrorView.setVisibility(GONE); mLoadingView.setVisibility(VISIBLE); break; case STATUS_SUCCESS: successView.setVisibility(VISIBLE); mErrorView.setVisibility(GONE); mLoadingView.setVisibility(GONE); break; &#125; &#125; public class NoBindViewException extends RuntimeException&#123; public NoBindViewException(String info)&#123; super(info); &#125; &#125;&#125; github地址: 点此进入]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android Studio2.2 新布局 ConstranintLayout入门]]></title>
    <url>%2F2017%2F05%2F16%2FConstranintLayout%2F</url>
    <content type="text"><![CDATA[android Studio2.2 新布局 ConstranintLayout入门今天发现AS更新2.2正式版本,同时给我们带来了一个新的布局ConstraintLayout,让我们来一起研究学习一下. 简单的来说,约束布局就是相对布局,强调控件之间的联系,同时能让你的布局减少层级嵌套需要的相关: android studio 2.2版本 打开AS就可以更新 在项目的build里添加依赖: 123dependencies &#123; compile &apos;com.android.support.constraint:constraint-layout:1.0.0-alpha8&apos;&#125; 在xml里定义:123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/cons&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.example.zhangqi.constranintlayout.MainActivity&quot;&gt; &lt;ImageView android:id=&quot;@+id/image&quot; android:src=&quot;@mipmap/ic_launcher&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 来看一下2.2给我们带来的PreView界面 现在我们把图片置于布局的中间我们该怎么做呢?在相对布局中我们可以使用下面这个属性使控件位于父布局中间1android:layout_centerInParent=&quot;true&quot; 而在约束布局中,我们则要对控件进行约束1234567891011&lt;ImageView android:id=&quot;@+id/image&quot; android:src=&quot;@mipmap/ic_launcher&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.49&quot; /&gt; 我们看到了添加了四个属性,单独拿出其中一个12app:layout_constraintBottom_toBottomOf=&quot;parent&quot;app:layout_constraint[我]_[目标]=&quot;[目标ID]&quot; 通俗的讲就是,[我] (imageView)的底部与目标ID的底部对[目标ID]控件的底部对齐,这样,我们就好理解了,其他属性也大致相同,这里可以写成parent既是与父布局约束,也可以使用id1app:layout_constraintBottom_toBottomOf=&quot;@id/cons&quot; 刚才在布局中,我们看到了类似蓝图一样的布局,我们发现控件的四周出现了控制器: 我们看到imageView正四周有圆形控制器,用来创建控件之间的约束,我们现在就来动手创建约束 通过手动方式,我们给imageView约束在父布局中,但是也看到了有默认的margin值.现在,既然可以添加约束,当然也可以清除约束,我们看一下在蓝图中,如何清除控件的约束. 最后我们来实现一个简单的效果,讲图片居中,并让蚊子置于图片右边平行 来看一下如何去操作,添加控件之间的约束 当然,这篇博客只是简单的玩了一下ConstranintLayout. 如果你运行程序出现了以下错误 12345Error:Execution failed for task &apos;:app:transformResourcesWithMergeJavaResForDebug&apos;.&gt; com.android.build.api.transform.TransformException: com.android.builder.packaging.DuplicateFileException: Duplicate files copied in APK META-INF/LICENSE File1: C:\Users\zhangqi\.gradle\caches\modules-2\files-2.1\com.fasterxml.jackson.core\jackson-databind\2.7.2\84ffa765dd258dbab8695963c41308b054f3a1cb\jackson-databind-2.7.2.jar File2: C:\Users\zhangqi\.gradle\caches\modules-2\files-2.1\com.fasterxml.jackson.core\jackson-core\2.7.2\8b8310381b690e317f5f0574e9b2dd7034778b4c\jackson-core-2.7.2.jar File3: C:\Users\zhangqi\.gradle\caches\modules-2\files-2.1\com.fasterxml.jackson.core\jackson-annotations\2.7.0\19f42c154ffc689f40a77613bc32caeb17d744e3\jackson-annotations-2.7.0.jar 请在app的build.gradle添加一下代码 1234packagingOptions &#123; exclude &apos;META-INF/NOTICE&apos; // will not include NOTICE file exclude &apos;META-INF/LICENSE&apos; // will not include LICENSE file &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ConstranintLayout</tag>
      </tags>
  </entry>
</search>