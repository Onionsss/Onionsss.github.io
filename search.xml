<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[极简的MVP设计模式配合UI框架]]></title>
    <url>%2F2017%2F05%2F16%2F%E6%9E%81%E7%AE%80MVP%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%E6%90%AD%E9%85%8DUI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[MVP可以实现视图和数据的解耦 ###如图所示 MVP使M与V分离 实现了解耦 定义BaseView 所有视图的通用接口(activity fragment)12345678910111213public interface BaseView &#123; /** * 初始化数据 */ void loadData(); /** * 更新View的状态 * @param state */ void updateState(int state);&#125; updateState整个方法是由我们来根据网络返回的数据或者来判断整个View的状态,定义了三个状态值,由此来展示loading页面 或者 error的页面123456//加载状态public static final int STATUS_LOADING = 100;//成功状态public static final int STATUS_SUCCESS = 101;//失败状态public static final int STATUS_ERROR = 102; 接着去定义通用的接口BaseViewImpl123456public interface BaseViewImpl&lt;D&gt; extends BaseView&#123; void attachPre(); void showData(List&lt;D&gt; list);&#125; attachPre 由View来关联相应的Presenter 可以在定义的BaseActivity里调用绑定PresenterBasePresenter123456789101112public interface BasePresenter&lt;V&gt; &#123; /** * 绑定View * @param view */ void attachView(V view); /** * 解绑View */ void detachView();&#125; BasePresenter的实现类 基类123456789101112131415161718192021222324252627282930313233343536373839404142public abstract class BasePresenterImpl&lt;V extends BaseView&gt; implements BasePresenter&lt;V&gt;&#123; public Context mContext; public V mBaseView; private CompositeSubscription mCompositeSubscription; public BasePresenterImpl(Context context)&#123; mContext = context; &#125; @Override public void attachView(V view) &#123; mBaseView = view; &#125; @Override public void detachView() &#123; this.mBaseView = null; onUnsubscribe(); //解绑 &#125; /** * 加载数据 */ public abstract void loadData(); //RXjava取消注册，以避免内存泄露 public void onUnsubscribe() &#123; if (mCompositeSubscription != null &amp;&amp; mCompositeSubscription.hasSubscriptions()) &#123; mCompositeSubscription.unsubscribe(); &#125; &#125; public void addSubscription(Observable observable, Subscriber subscriber) &#123; if (mCompositeSubscription == null) &#123; mCompositeSubscription = new CompositeSubscription(); &#125; mCompositeSubscription.add(subscriber); &#125;&#125; 在BasePresenterImpl里绑定View ,由此子类可以根据View来更新状态MVP就是基类的实现就是这么简单,现在来创建activity来试试手, 首先创建一个BaseActivity,抽取一些公共的代码1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class BaseActivity&lt;T extends BasePresenter,D&gt; extends AppCompatActivity implements BaseViewImpl&lt;D&gt;&#123; public T mPresenter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); /** * 绑定Presenter */ attachPre(); View view = initView(LayoutInflater.from(this)); setContentView(view); ButterKnife.bind(this); findView(view); loadData(); &#125; protected abstract View initView(LayoutInflater from); public abstract void findView(View view); @Override protected void onDestroy() &#123; super.onDestroy(); if(mPresenter != null) mPresenter.detachView(); ButterKnife.unbind(this); &#125; /** * error的统一处理 * @param error */ public void error(Throwable error)&#123; if(error instanceof NetworkErrorException)&#123; Toast.makeText(this,&quot;网络错误&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 创建HomeActivity去访问网络以及加载数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class HomeActivity extends BaseActivity&lt;HomePresenter, NewsList.NewsEntity&gt; &#123; @Bind(R.id.recy) RecyclerView mRecy; private NewsListAdapter mNewsListAdapter; private LoadStuatus mLoadStuatus; @Override public View initView(LayoutInflater inflater) &#123; /** * UI框架 */ mLoadStuatus = new LoadStuatus(this); /** * 实现成功页面的View */ mLoadStuatus.addSuccessView(inflater.inflate(R.layout.activity_home, null)); /** * 绑定BaseView来实现页面点击加载 */ mLoadStuatus.bindView(this); return mLoadStuatus; &#125; @Override public void findView(View view) &#123; mRecy.setLayoutManager(new LinearLayoutManager(this)); mNewsListAdapter = new NewsListAdapter(this); mRecy.setAdapter(mNewsListAdapter); &#125; @Override public void attachPre() &#123; mPresenter = new HomePresenter(this); mPresenter.attachView(this); &#125; @Override public void showData(List&lt;NewsList.NewsEntity&gt; list) &#123; mNewsListAdapter.flush(list); &#125; @Override public void loadData() &#123; mPresenter.loadData(); &#125; /** * 更新页面 */ @Override public void updateState(int state) &#123; mLoadStuatus.updateView(state); &#125;&#125; 这里的loadStuatus是一个帧布局用来存放我们的三个页面errorPage,LoadPage,SuccessPage都是根据P层的回调来实现在来看一下P层的实现1234567891011121314151617181920public class HomePresenter extends BasePresenterImpl&lt;HomeActivity&gt;&#123; public HomePresenter(Context context) &#123; super(context); &#125; @Override public void loadData() &#123; Subscription subscribe = RetrofitUtils.getinstance(mContext).buildNews().getNews() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(bean -&gt; mBaseView.showData(bean.getNews()), //onNext() 去更新页面 error -&gt; &#123; mBaseView.error(error); // 请求网络失败 在BaseActivity定义了公共的处理方法 mBaseView.updateState(LoadStuatus.STATUS_ERROR); //更新页面 显示失败的页面 &#125;, () -&gt; mBaseView.updateState(LoadStuatus.STATUS_SUCCESS));// onComplete 完成页面更新,显示成功的页面 addSubscription(subscribe); &#125;&#125; P层很简单 就是访问网络 当请求接下来看一下我们的UI框架 定义了统一处理页面状态的状态码以及如何去正确的显示页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class LoadStuatus extends FrameLayout &#123; private static final String TAG = &quot;TAG&quot;; BaseView nView; @Bind(R.id.error) View mErrorView; @Bind(R.id.loading) View mLoadingView; View successView; //加载状态 public static final int STATUS_LOADING = 100; //成功状态 public static final int STATUS_SUCCESS = 101; //失败状态 public static final int STATUS_ERROR = 102; public LoadStuatus(Context context) &#123; this(context, null); &#125; public LoadStuatus(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public LoadStuatus(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; public void addSuccessView(View view)&#123; successView = view; addView(successView); successView.setVisibility(GONE); &#125; public void bindView(BaseView view) &#123; this.nView = view; mErrorView.setOnClickListener(v -&gt; &#123; if(nView == null) throw new NoBindViewException(&quot;没有绑定View&quot;); nView.loadData(); &#125;); &#125; public void init() &#123; View.inflate(getContext(), R.layout.status, this); ButterKnife.bind(this); &#125; public void updateView(int currentStatus) &#123; switch (currentStatus) &#123; case STATUS_ERROR: successView.setVisibility(GONE); mErrorView.setVisibility(VISIBLE); mLoadingView.setVisibility(GONE); break; case STATUS_LOADING: successView.setVisibility(GONE); mErrorView.setVisibility(GONE); mLoadingView.setVisibility(VISIBLE); break; case STATUS_SUCCESS: successView.setVisibility(VISIBLE); mErrorView.setVisibility(GONE); mLoadingView.setVisibility(GONE); break; &#125; &#125; public class NoBindViewException extends RuntimeException&#123; public NoBindViewException(String info)&#123; super(info); &#125; &#125;&#125; github地址: 点此进入]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>